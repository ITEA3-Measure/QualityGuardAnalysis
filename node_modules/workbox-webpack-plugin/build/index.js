'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
  Copyright 2017 Google Inc.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/

var path = require('path');

var _require = require('workbox-build'),
    getModuleUrl = _require.getModuleUrl;

var generateManifest = require('./lib/generate-manifest-with-webpack');
var generateOrCopySW = require('./lib/generate-or-copy-sw');
var getAssetHash = require('./lib/utils/get-asset-hash');
var getEntries = require('./lib/get-manifest-entries-with-webpack');
var formatAsWebpackAsset = require('./lib/utils/format-as-webpack-asset');

var _require2 = require('./lib/utils/read-file'),
    setReadFile = _require2.setReadFile;

/**
 * This module exports the `WorkboxWebpackPlugin`.
 *
 * Use an instance of `WorkboxWebpackPlugin` in the
 * [`plugins` array](https://webpack.js.org/concepts/plugins/#usage) of a
 * webpack config.
 *
 * @module workbox-webpack-plugin
 */


var WorkboxWebpackPlugin = function () {
  /**
   * Creates an instance of WorkboxWebpackPlugin.
   *
   * @param {module:workbox-build.Configuration} [config] All the options as
   *        passed to {@link module:workbox-build.generateSWString}.
   * @param {Array<String>} [config.chunks] Array of chunk names to use for
   *        generating the asset manifest. All assets belonging to the provided
   *        chunk names will be included in the asset manifest. Any chunks that
   *        are not listed or do not have a name will be removed.
   * @param {Array<String>} [config.excludeChunks] Array of chunk names to
   *        exclude from the asset manifest. Any asset beloning to the provided
   *        chunk names will not be included in the asset manifest. This does
   *        not affect chunks with no chunk name.
   * @param {string} [config.filename = 'sw.js'] Name of the service worker file
   * @param {string} [config.manifestFilename = 'file-manifest[hash].js'] Name
   *        of the manifest file that will be written to the build directory
   * @param {string} [config.swSrc] Path to an existing service worker file.
   *        Will be added to the webpack compilation and prepended with
   *        importScripts('workbox-sw.js', 'file-manifest.js')
   */
  function WorkboxWebpackPlugin() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, WorkboxWebpackPlugin);

    this.config = config;
  }

  /**
   * @return {Object} All workbox configuration options that can be accepted
   * by {@link module:workbox-build.generateSWString}
   *
   * @private
   */


  (0, _createClass3.default)(WorkboxWebpackPlugin, [{
    key: 'apply',


    /**
     * @param {Object} [compiler] default compiler object passed from webpack
     *
     * @private
     */
    value: function apply(compiler) {
      var _this = this;

      /**
       * The plugin was instantiated and the webpack compilation has just begun.
       * We configure the workbox-webpack-plugin/utils/read-file module to use
       * webpack's compilation.inputFileSystem._readFile method for reading files.
       *
       * TODO: Determine if this is absolutely necessary. It might be possible to
       * only do this in development (when the file system is a "memory" file
       * system). If that is the case, it might be better to set different values
       * for setReadFile using compiler.plugin('run') for production and
       * compiler.plugin('watch-run') for development.
       */
      setReadFile(compiler.inputFileSystem._readFile);

      /**
       * During the emit phase of the webpack compilation, we:
       *  1. Get the manifest entries.
       *  2. Use the entries to generate a file-manifest.
       *  3. Generate a service worker with the file-manifest name and workbox-sw
       *     name, or copy a service worker from the config.swSrc, then prepend
       *     it with the required importScripts(workbox-sw.js, file-manifest.js).
       *  4. Add both the file-manifest and the service worker to the webpack
       *     assets.
       */
      compiler.plugin('emit', function () {
        var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(compilation, next) {
          var swSrc, serviceWorkerFilename, entries, fileManifest, fileManifestAsset, fileManifestHash, manifestFilename, serviceWorker;
          return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  swSrc = _this.config.swSrc;
                  serviceWorkerFilename = swSrc ? path.basename(swSrc) : 'sw.js';
                  entries = getEntries(compilation, _this.config);
                  fileManifest = generateManifest(entries);
                  fileManifestAsset = formatAsWebpackAsset(fileManifest);
                  fileManifestHash = getAssetHash(fileManifestAsset);
                  manifestFilename = `precache-manifest.${fileManifestHash}.js`;

                  compilation.assets[manifestFilename] = fileManifestAsset;

                  _this.config.importScripts = (_this.config.importScripts || []).concat([getModuleUrl('workbox-sw'), manifestFilename]);

                  _context.next = 11;
                  return generateOrCopySW(_this.config, swSrc);

                case 11:
                  serviceWorker = _context.sent;

                  compilation.assets[serviceWorkerFilename] = formatAsWebpackAsset(serviceWorker);

                  next();

                case 14:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, _this);
        }));

        return function (_x2, _x3) {
          return _ref.apply(this, arguments);
        };
      }());
    }
  }, {
    key: 'generateSWStringOptions',
    get: function get() {
      var _config$importScripts = this.config.importScripts,
          importScripts = _config$importScripts === undefined ? [] : _config$importScripts;


      return {
        importScripts
      };
    }
  }]);
  return WorkboxWebpackPlugin;
}();

module.exports = WorkboxWebpackPlugin;